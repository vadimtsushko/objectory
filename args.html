        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>args Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        </head>
        <body data-library="args">
        <div class="page">
        <div class="header">
          <a href="index.html"><div class="logo"></div></a>
          <a href="index.html">Dart Documentation</a>
         &rsaquo; <a href="args.html">args</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
<h2><strong>args</strong> library</h2>
<div class="doc"><p>Parser support for transforming raw command-line arguments into a set
of options and values.</p>
<p>This library supports <a href="http://www.gnu.org/prep/standards/standards.html#Command_002dLine-Interfaces">GNU</a> and <a href="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html#tag_12_02">POSIX</a> style options, and it works
in both server-side and client-side apps.</p>
<p>For information on installing this library, see the
<a href="http://pub.dartlang.org/packages/args">args package on pub.dartlang.org</a>.
Here's an example of importing this library:</p>
<pre><code>import 'package:args/args.dart';
</code></pre>
<h2>Defining options</h2>
<p>To use this library, first create an <a class="crossref" href="args/ArgParser.html">ArgParser</a>:</p>
<pre><code>var parser = new ArgParser();
</code></pre>
<p>Then define a set of options on that parser using <code>addOption()</code> and
<code>addFlag()</code>. Here's the minimal way to create an option named "name":</p>
<pre><code>parser.addOption('name');
</code></pre>
<p>When an option can only be set or unset (as opposed to taking a string
value), use a flag:</p>
<pre><code>parser.addFlag('name');
</code></pre>
<p>Flag options, by default, accept a 'no-' prefix to negate the option.
You can disable the 'no-' prefix using the <code>negatable</code> parameter:</p>
<pre><code>parser.addFlag('name', negatable: false);
</code></pre>
<p><strong>Terminology note:</strong>
From here on out, the term <em>option</em> refers to both regular options and
flags. In cases where the distinction matters, this documentation uses
the term <em>non-flag option.</em></p>
<p>Options can have an optional single-character abbreviation, specified
with the <code>abbr</code> parameter:</p>
<pre><code>parser.addOption('mode', abbr: 'm');
parser.addFlag('verbose', abbr: 'v');
</code></pre>
<p>Options can also have a default value, specified with the <code>defaultsTo</code>
parameter. The default value is used when arguments don't specify the
option.</p>
<pre><code>parser.addOption('mode', defaultsTo: 'debug');
parser.addFlag('verbose', defaultsTo: false);
</code></pre>
<p>The default value for non-flag options can be any <a class="crossref" href="http://api.dartlang.org/dart_core/String.html">String</a>. For flags,
it must be a <a class="crossref" href="http://api.dartlang.org/dart_core/bool.html">bool</a>.</p>
<p>To validate a non-flag option, you can use the <code>allowed</code> parameter to
provide an allowed set of values. When you do, the parser throws a
<a class="crossref" href="http://api.dartlang.org/dart_core/FormatException.html">FormatException</a> if the value for an option is not in the allowed set.
Here's an example of specifying allowed values:</p>
<pre><code>parser.addOption('mode', allowed: ['debug', 'release']);
</code></pre>
<p>You can use the <code>callback</code> parameter to associate a function with an
option. Later, when parsing occurs, the callback function is invoked
with the value of the option:</p>
<pre><code>parser.addOption('mode', callback: (mode) =&gt; print('Got mode $mode));
parser.addFlag('verbose', callback: (verbose) {
  if (verbose) print('Verbose');
});
</code></pre>
<p>The callbacks for all options are called whenever a set of arguments
is parsed. If an option isn't provided in the args, its callback is
passed the default value, or <code>null</code> if no default value is set.</p>
<h2>Parsing arguments</h2>
<p>Once you have an <a class="crossref" href="args/ArgParser.html">ArgParser</a> set up with some options and flags, you
use it by calling <a class="crossref" href="args/ArgParser.html#parse">ArgParser.parse()</a> with a set of arguments:</p>
<pre><code>var results = parser.parse(['some', 'command', 'line', 'args']);
</code></pre>
<p>These arguments usually come from the arguments to main
(<code>main(List&lt;String&gt; arguments</code>), but you can pass in any list of strings.
The parse() method returns an instance of <a class="crossref" href="args/ArgResults.html">ArgResults</a>, a map-like
object that contains the values of the parsed options.</p>
<pre><code>var parser = new ArgParser();
parser.addOption('mode');
parser.addFlag('verbose', defaultsTo: true);
var results = parser.parse(['--mode', 'debug', 'something', 'else']);

print(results['mode']); // debug
print(results['verbose']); // true
</code></pre>
<p>By default, the parse() method stops as soon as it reaches <code>--</code> by itself
or anything that the parser doesn't recognize as an option, flag, or
option value. If arguments still remain, they go into <a class="crossref" href="args/ArgResults.html#rest">ArgResults.rest</a>.</p>
<pre><code>print(results.rest); // ['something', 'else']
</code></pre>
<p>To continue to parse options found after non-option arguments, call
parse() with <code>allowTrailingOptions: true</code>.</p>
<h2>Specifying options</h2>
<p>To actually pass in options and flags on the command line, use GNU or
POSIX style. Consider this option:</p>
<pre><code>parser.addOption('name', abbr: 'n');
</code></pre>
<p>You can specify its value on the command line using any of the following:</p>
<pre><code>--name=somevalue
--name somevalue
-nsomevalue
-n somevalue
</code></pre>
<p>Consider this flag:</p>
<pre><code>parser.addFlag('name', abbr: 'n');
</code></pre>
<p>You can set it to true using one of the following:</p>
<pre><code>--name
-n
</code></pre>
<p>You can set it to false using the following:</p>
<pre><code>--no-name
</code></pre>
<p>Multiple flag abbreviations can be collapsed into a single argument. Say
you define these flags:</p>
<pre><code>parser.addFlag('verbose', abbr: 'v');
parser.addFlag('french', abbr: 'f');
parser.addFlag('iambic-pentameter', abbr: 'i');
</code></pre>
<p>You can set all three flags at once:</p>
<pre><code>-vfi
</code></pre>
<p>By default, an option has only a single value, with later option values
overriding earlier ones; for example:</p>
<pre><code>var parser = new ArgParser();
parser.addOption('mode');
var results = parser.parse(['--mode', 'on', '--mode', 'off']);
print(results['mode']); // prints 'off'
</code></pre>
<p>If you need multiple values, set the <code>allowMultiple</code> parameter. In that
case the option can occur multiple times, and the parse() method returns
a list of values:</p>
<pre><code>var parser = new ArgParser();
parser.addOption('mode', allowMultiple: true);
var results = parser.parse(['--mode', 'on', '--mode', 'off']);
print(results['mode']); // prints '[on, off]'
</code></pre>
<h2>Defining commands</h2>
<p>In addition to <em>options</em>, you can also define <em>commands</em>. A command is
a named argument that has its own set of options. For example, consider
this shell command:</p>
<pre><code>$ git commit -a
</code></pre>
<p>The executable is <code>git</code>, the command is <code>commit</code>, and the <code>-a</code> option is
an option passed to the command. You can add a command using the
<code>addCommand</code> method:</p>
<pre><code>var parser = new ArgParser();
var command = parser.addCommand('commit');
</code></pre>
<p>The addCommand() method returns another <a class="crossref" href="args/ArgParser.html">ArgParser</a>, which you can then
use to define options specific to that command. If you already have an
<a class="crossref" href="args/ArgParser.html">ArgParser</a> for the command's options, you can pass it to addCommand:</p>
<pre><code>var parser = new ArgParser();
var command = new ArgParser();
parser.addCommand('commit', command);
</code></pre>
<p>The <a class="crossref" href="args/ArgParser.html">ArgParser</a> for a command can then define options or flags:</p>
<pre><code>command.addFlag('all', abbr: 'a');
</code></pre>
<p>You can add multiple commands to the same parser so that a user can select
one from a range of possible commands. When parsing an argument list,
you can then determine which command was entered and what options were
provided for it.</p>
<pre><code>var results = parser.parse(['commit', '-a']);
print(results.command.name);   // "commit"
print(results.command['all']); // true
</code></pre>
<p>Options for a command must appear after the command in the argument list.
For example, given the above parser, "git -a commit" is <em>not</em> valid. The
parser tries to find the right-most command that accepts an option. For
example:</p>
<pre><code>var parser = new ArgParser();
parser.addFlag('all', abbr: 'a');
var command = parser.addCommand('commit');
command.addFlag('all', abbr: 'a');

var results = parser.parse(['commit', '-a']);
print(results.command['all']); // true
</code></pre>
<p>Here, both the top-level parser and the "commit" command can accept a
"-a" (which is probably a bad command line interface, admittedly). In
that case, when "-a" appears after "commit", it is applied to that
command. If it appears to the left of "commit", it is given to the
top-level parser.</p>
<h2>Displaying usage</h2>
<p>You can automatically generate nice help text, suitable for use as the
output of <code>--help</code>. To display good usage information, you should
provide some help text when you create your options.</p>
<p>To define help text for an entire option, use the <code>help</code> parameter:</p>
<pre><code>parser.addOption('mode', help: 'The compiler configuration',
    allowed: ['debug', 'release']);
parser.addFlag('verbose', help: 'Show additional diagnostic info');
</code></pre>
<p>For non-flag options, you can also provide detailed help for each expected
value by using the <code>allowedHelp</code> parameter:</p>
<pre><code>parser.addOption('arch', help: 'The architecture to compile for',
    allowedHelp: {
      'ia32': 'Intel x86',
      'arm': 'ARM Holding 32-bit chip'
    });
</code></pre>
<p>To display the help, use the ArgParser getUsage() method:</p>
<pre><code>print(parser.getUsage());
</code></pre>
<p>The resulting string looks something like this:</p>
<pre><code>--mode            The compiler configuration
                  [debug, release]

--[no-]verbose    Show additional diagnostic info
--arch            The architecture to compile for

      [arm]       ARM Holding 32-bit chip
      [ia32]      Intel x86
</code></pre>
<p>To assist the formatting of the usage help, single-line help text is
followed by a single new line. Options with multi-line help text are
followed by two new lines. This provides spatial diversity between options.</p></div>
<h3>Exports</h3>
<ul>
<ul><a href="options.html">options</a></ul>
</ul>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="args/ArgParser.html"><strong>ArgParser</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="args/ArgResults.html"><strong>ArgResults</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="client-live-nav.js"></script>
        </body></html>
        
